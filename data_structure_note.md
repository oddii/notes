# 数据结构

## 1、算法效率的度量

### 1.1、时间复杂度

> 概念

**事前预估**算法**时间开销 `T(n)`** 与**问题规模 `n`** 的关系（ `T` 表示 `time`）

- 加法规则： 多项相加，只保留最高阶的项，且系数变为1
    $$
    T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n), g(n)))
    $$
    

- 乘法规则：多项相乘，都保留
    $$
    T_1(n) = T_1(n) \times T_2(n) = O(f(n)) \times O(g(n)) = O(f(n) \times g(n))
    $$

常用复杂度比较：
$$
O(1)<O(\log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$
比较口诀：**常对幂指阶**

> 时间复杂度的计算

- 顺序执行的代码只会影响常数项，可以忽略
- 只需挑**循环**中**一个基本操作**分析它的执行次数与 `n` 的关系即可
- 如果有**多层嵌套循环**，只需关注**最深层循环**的执行次数与 `n` 的关系

> 练习

1. 指数递增型算法

    ```c
    void loveYou(int n){	//	n	为问题规模
    		int i = 1;	
     		while(i <= n){
          	i = i * 2;	//	每次翻倍
          	printf("I Love You %d\n", i);
        }
      	printf("I Love You More Than %d\n", n);
    }
    ```

    设最深层循环的语句频度（总共循环的次数）为 `x`，则由循环条件可知，循环结束时刚好满足 `2^x` > `n`，`x` = `log_2n` + `1`，所以该算法的时间复杂度为 `O(log_2n)`

2. 搜索数字型算法

    ```c
    void loveYou(int flag[], int n){	//	n 为问题规模
      	printf("I Am Iron Man\n");
      	for(int i = 0; i < n; i++){	//	从第一个元素开始查找
          	if(flag[i] == n){	//	找到元素 n
              	printf("I Love You %d\n", n);
              	break;	//	找到后跳出循环
            }
        }
    }
    
    int flag[n] = {1...n};	//	数组中乱序存放了 1 ~ n 这些数
    loveYou(flag, n);
    ```

    最好情况：元素 `n` 在第一个位置，最好时间复杂度为 `T(n)` = `O(1)`（通常不考虑）

    最坏情况：元素 `n` 在最后一个位置，最坏时间复杂度为 `T(n)` = `O(n)`

    平均情况：假设元素 `n` 在任意一个位置的概率相同为 `1/n`，所以循环次数为 `1+n/2`，即平均时间复杂度为 `T(n)` = `O(n)`

### 1.2、空间复杂度

## 2、线性表

> 定义

线性表是具有**相同数据类型**的 `n` （`n >= 0` ）个**数据元素**的**有限序列**，其中 `n` 为**表长**，当 `n = 0` 时线性表是一个**空表**，若用 `L` 命名线性表，则其一般表示为：
$$
L = (a_1,a_2,...,a_i,a_{i+1},a_n)
$$
几个概念：

- `a_i` 是线性表中的 “第 `i` 个” 元素线性表中的**位序**
- `a_1` 是**表头元素**，`a_n` 是**表尾元素**
- 除第一个元素外，每个元素有且仅有一个**直接前驱**；除最后一个元素外，每个元素有且仅有一个**直接后继**

> 基本操作

- `InitList(& L)`：**初始化**表。构造一个空的线性表 `L`，**分配内存空间**
- `DestroyList(& L)`：**销毁**操作。销毁线性表，并**释放**线性表 `L` 所占用的**内存空间**

### 2.1、顺序表

> 定义

用**顺序存储**的方式实现线性表顺序存储。把**逻辑上相邻**的元素存储在**物理位置上也相邻**的存储单元中，元素之间的关系由存储单元的邻接关系来体现